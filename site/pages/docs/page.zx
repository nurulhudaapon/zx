pub fn Page(ctx: zx.PageContext) zx.Component {
    // var page_timer = std.time.Timer.start() catch unreachable;
    const allocator = ctx.arena;

    // std.log.info("\x1b[1;36m[DOCS PAGE] Starting page generation...\x1b[0m", .{});

    // If example
    var aw_if: std.io.Writer.Allocating = .init(allocator);
    const zx_example_if = @embedFile("../../../pages/examples/if.zx");
    const zig_example_if = @embedFile("../examples/if.zig");
    const html_page_if = @import("../examples/if.zig").Page(allocator);
    html_page_if.render(&aw_if.writer) catch unreachable;
    const html_example_if = allocator.dupe(u8, aw_if.written()) catch unreachable;

    // Switch example
    var aw_switch: std.io.Writer.Allocating = .init(allocator);
    const zx_example_switch = @embedFile("../../../pages/examples/switch.zx");
    const zig_example_switch = @embedFile("../examples/switch.zig");
    const html_page_switch = @import("../examples/switch.zig").Page(allocator);
    html_page_switch.render(&aw_switch.writer) catch unreachable;
    const html_example_switch = allocator.dupe(u8, aw_switch.written()) catch unreachable;

    // For example
    var aw_for: std.io.Writer.Allocating = .init(allocator);
    const zx_example_for = @embedFile("../../../pages/examples/for.zx");
    const zig_example_for = @embedFile("../examples/for.zig");
    const html_page_for = @import("../examples/for.zig").Page(allocator);
    html_page_for.render(&aw_for.writer) catch unreachable;
    const html_example_for = allocator.dupe(u8, aw_for.written()) catch unreachable;

    // Component expression example
    var aw_component: std.io.Writer.Allocating = .init(allocator);
    const zx_example_component = @embedFile("../../../pages/examples/component.zx");
    const zig_example_component = @embedFile("../examples/component.zig");
    const html_page_component = @import("../examples/component.zig").Page(allocator);
    html_page_component.render(&aw_component.writer) catch unreachable;
    const html_example_component = allocator.dupe(u8, aw_component.written()) catch unreachable;

    // Text expression example
    var aw_text: std.io.Writer.Allocating = .init(allocator);
    const zx_example_text = @embedFile("../../../pages/examples/text.zx");
    const zig_example_text = @embedFile("../examples/text.zig");
    const html_page_text = @import("../examples/text.zig").Page(allocator);
    html_page_text.render(&aw_text.writer) catch unreachable;
    const html_example_text = allocator.dupe(u8, aw_text.written()) catch unreachable;

    // Format expression example
    var aw_format: std.io.Writer.Allocating = .init(allocator);
    const zx_example_format = @embedFile("../../../pages/examples/format.zx");
    const zig_example_format = @embedFile("../examples/format.zig");
    const html_page_format = @import("../examples/format.zig").Page(allocator);
    html_page_format.render(&aw_format.writer) catch unreachable;
    const html_example_format = allocator.dupe(u8, aw_format.written()) catch unreachable;

    // Components example
    var aw_components: std.io.Writer.Allocating = .init(allocator);
    const zx_example_components = @embedFile("../../../pages/examples/components.zx");
    const zig_example_components = @embedFile("../examples/components.zig");
    const html_page_components = @import("../examples/components.zig").Page(ctx);
    html_page_components.render(&aw_components.writer) catch unreachable;
    const html_example_components = allocator.dupe(u8, aw_components.written()) catch unreachable;

    // Routing example
    var aw_routing: std.io.Writer.Allocating = .init(allocator);
    const zx_example_routing = @embedFile("../../../pages/examples/routing.zx");
    const zig_example_routing = @embedFile("../examples/routing.zig");
    const html_page_routing = @import("../examples/routing.zig").Page(ctx);
    html_page_routing.render(&aw_routing.writer) catch unreachable;
    const html_example_routing = allocator.dupe(u8, aw_routing.written()) catch unreachable;

    // Layout example
    var aw_layout: std.io.Writer.Allocating = .init(allocator);
    const zx_example_layout = @embedFile("../../../pages/layout.zx");
    const zig_example_layout = @embedFile("../examples/layout.zig");
    const layoutctx = zx.LayoutContext.init(ctx.request, ctx.response, ctx.allocator);
    const html_page_layout = @import("../examples/layout.zig").Layout(layoutctx, html_page_routing);
    html_page_layout.render(&aw_layout.writer) catch unreachable;
    const html_example_layout = allocator.dupe(u8, aw_layout.written()) catch unreachable;

    // Allocator example
    var aw_allocator: std.io.Writer.Allocating = .init(allocator);
    const zx_example_allocator = @embedFile("../../../pages/examples/allocator.zx");
    const zig_example_allocator = @embedFile("../examples/allocator.zig");
    const html_page_allocator = @import("../examples/allocator.zig").Page(ctx);
    html_page_allocator.render(&aw_allocator.writer) catch unreachable;
    const html_example_allocator = allocator.dupe(u8, aw_allocator.written()) catch unreachable;

    const cmp_expr = "{(expression)}";
    const txt_expr = "{expression}";
    const fmt_expr = "{[expression:format]}";

    // Escaping example
    var aw_escaping: std.io.Writer.Allocating = .init(allocator);
    const zx_example_escaping = @embedFile("../../../pages/examples/escaping.zx");
    const zig_example_escaping = @embedFile("../examples/escaping.zig");
    const html_page_escaping = @import("../examples/escaping.zig").Page(allocator);
    html_page_escaping.render(&aw_escaping.writer) catch unreachable;
    const html_example_escaping = allocator.dupe(u8, aw_escaping.written()) catch unreachable;

    // CSR example
    var aw_csr: std.io.Writer.Allocating = .init(allocator);
    const zx_example_csr = @embedFile("../../../pages/examples/csr.zx");
    const zig_example_csr = @embedFile("../examples/csr.zig");
    const html_page_csr = @import("../examples/csr.zig").Page(allocator);
    html_page_csr.render(&aw_csr.writer) catch unreachable;
    const html_example_csr = allocator.dupe(u8, aw_csr.written()) catch unreachable;

    // Importing example
    var aw_importing: std.io.Writer.Allocating = .init(allocator);
    const zx_example_importing = @embedFile("../../../pages/examples/importing.zx");
    const zig_example_importing = @embedFile("../examples/importing.zig");
    const html_page_importing = @import("../examples/importing.zig").Page(allocator);
    html_page_importing.render(&aw_importing.writer) catch unreachable;
    const html_example_importing = allocator.dupe(u8, aw_importing.written()) catch unreachable;

    // Dynamic route example
    var aw_dynamic: std.io.Writer.Allocating = .init(allocator);
    const zx_example_dynamic = @embedFile("../../../pages/examples/dynamic_route.zx");
    const zig_example_dynamic = @embedFile("../examples/dynamic_route.zig");
    const html_page_dynamic = @import("../examples/dynamic_route.zig").Page(ctx);
    html_page_dynamic.render(&aw_dynamic.writer) catch unreachable;
    const html_example_dynamic = allocator.dupe(u8, aw_dynamic.written()) catch unreachable;

    // Fragment example
    var aw_fragment: std.io.Writer.Allocating = .init(allocator);
    const zx_example_fragment = @embedFile("../../../pages/examples/fragment.zx");
    const zig_example_fragment = @embedFile("../examples/fragment.zig");
    const html_page_fragment = @import("../examples/fragment.zig").Page(allocator);
    html_page_fragment.render(&aw_fragment.writer) catch unreachable;
    const html_example_fragment = allocator.dupe(u8, aw_fragment.written()) catch unreachable;

    // Children example
    var aw_children: std.io.Writer.Allocating = .init(allocator);
    const zx_example_children = @embedFile("../../../pages/examples/children.zx");
    const zig_example_children = @embedFile("../examples/children.zig");
    const html_page_children = @import("../examples/children.zig").Page(allocator);
    html_page_children.render(&aw_children.writer) catch unreachable;
    const html_example_children = allocator.dupe(u8, aw_children.written()) catch unreachable;

    // const setup_elapsed_ns = page_timer.read();
    // const setup_elapsed_ms = @as(f64, @floatFromInt(setup_elapsed_ns)) / @as(f64, @floatFromInt(std.time.ns_per_ms));
    // std.log.info("\x1b[1;36m[DOCS PAGE] Setup phase completed: {d:.3}ms\x1b[0m", .{setup_elapsed_ms});

    return (
        <div @allocator={allocator}>
            <Introduction />
            <GettingStarted />
            <section id="expressions" class="section">
                <h2>Expressions</h2>
                <p>ZX provides different expression syntaxes for embedding dynamic content. Each syntax serves a specific purpose: rendering components, displaying text safely, or formatting values with custom format specifiers.</p>
                <h3>Text Expressions</h3>
                <p>Use <code>{txt_expr}</code> to embed text content. All text is automatically HTML-escaped to prevent XSS attacks. This is the safe way to display user input or dynamic text content.</p>
                <ExampleBlock id="text" zx_code={zx_example_text} zig_code={zig_example_text} html_code={html_example_text} />
                <h3>Format Expressions</h3>
                <p>Use <code>{fmt_expr}</code> to format values with custom format specifiers. The format string follows Zig's standard format specifier syntax (e.g., <code>d</code> for decimal, <code>x</code> for hexadecimal). Unlike text expressions, format expressions are not HTML-escaped, making them suitable for numeric formatting and other non-HTML content.</p>
                <ExampleBlock id="format" zx_code={zx_example_format} zig_code={zig_example_format} html_code={html_example_format} />
                <h3>Component Expressions</h3>
                <p>Use <code>{cmp_expr}</code> to embed a component directly. The expression must evaluate to a<code>zx.Component</code> type. This is useful when you want to conditionally render or reuse components dynamically.</p>
                <ExampleBlock id="component" zx_code={zx_example_component} zig_code={zig_example_component} html_code={html_example_component} />
            </section>
            <section id="control-flow" class="section">
                <h2>Control Flow</h2>
                <p>ZX supports conditional rendering and iteration using familiar Zig control flow constructs. These expressions allow you to conditionally render components or iterate over collections to build dynamic UIs.</p>
                <h3>If Statements</h3>
                <p>Use <code>if</code> expressions to conditionally render components based on boolean conditions. The<code>else</code> branch is optional and can render alternative content when the condition is false.</p>
                <ExampleBlock id="if" zx_code={zx_example_if} zig_code={zig_example_if} html_code={html_example_if} />
                <h3>Switch Statements</h3>
                <p>Use <code>switch</code> expressions to match against enum values or other types. Each case can return either a string literal or a component. Switch expressions are particularly useful for rendering different UI based on state or user roles.</p>
                <ExampleBlock id="switch" zx_code={zx_example_switch} zig_code={zig_example_switch} html_code={html_example_switch} />
                <h3>For Loops</h3>
                <p>Use <code>for</code> loops to iterate over arrays, slices, or strings and render a component for each item. The loop variable can be used within the component body to display item-specific content. This is ideal for rendering lists, tables, or any repeating UI patterns.</p>
                <ExampleBlock id="for" zx_code={zx_example_for} zig_code={zig_example_for} html_code={html_example_for} />
            </section>
            <section id="components" class="section">
                <h2>Components</h2>
                <p>Components are reusable functions that return <code>zx.Component</code>. They allow you to encapsulate UI logic and create modular, maintainable code. Components can accept props (properties) to customize their behavior and appearance.</p>
                <h3>Component Function Signatures</h3>
                <p>Component functions must follow one of two signatures:</p>
                <ul>
                    <li><strong>Single parameter (allocator only):</strong><code>fn ComponentName(allocator: zx.Allocator) zx.Component</code></li>
                    <li><strong>Two parameters (allocator and props):</strong><code>fn ComponentName(allocator: zx.Allocator, props: PropsType) zx.Component</code></li>
                </ul>
                <h3>Defining Components</h3>
                <p>To create a component, define a function that returns a <code>zx.Component</code>. The function must have an allocator as its first parameter. If your component needs configuration, add a props struct as the second parameter:</p>
                <ExampleBlock id="components" zx_code={zx_example_components} zig_code={zig_example_components} html_code={html_example_components} />
                <h3>Props Coercion</h3>
                <p>ZX automatically coerces the attributes you pass to a component into the expected props struct. Missing required fields will result in a compile-time error, while fields with default values are optional. This provides type safety while keeping component usage flexible.</p>
            </section>
            <section id="routing" class="section">
                <h2>Routing</h2>
                <p>ZX provides a file-based routing system that maps URL paths to page components. Routes can be nested, and layouts can be applied hierarchically to wrap pages with common UI elements.</p>
                <h3>Pages</h3>
                <p>Pages are the main content components for each route. A page function must:</p>
                <ul>
                    <li>Accept a <code>zx.PageContext</code> as its only parameter</li>
                    <li>Return a <code>zx.Component</code></li>
                    <li>Be exported as <code>pub fn Page</code></li>
                </ul>
                <ExampleBlock id="routing" zx_code={zx_example_routing} zig_code={zig_example_routing} html_code={html_example_routing} />
                <h3>Layouts</h3>
                <p>Layouts wrap pages with common UI elements like headers, footers, or navigation. A layout function must:</p>
                <ul>
                    <li>Accept a <code>zx.LayoutContext</code> as the first parameter</li>
                    <li>Accept a <code>zx.Component</code> (the page content) as the second parameter</li>
                    <li>Return a <code>zx.Component</code></li>
                    <li>Be exported as <code>pub fn Layout</code></li>
                </ul>
                <ExampleBlock id="layout" zx_code={zx_example_layout} zig_code={zig_example_layout} html_code={html_example_layout} />
                <h3>PageContext and LayoutContext</h3>
                <p>Both <code>PageContext</code> and <code>LayoutContext</code> provide access to:</p>
                <ul>
                    <li><code>request</code>: The HTTP request object with headers, query params, body, etc.</li>
                    <li><code>response</code>: The HTTP response object for setting headers and writing the response</li>
                    <li><code>allocator</code>: Global allocator for persistent allocations (freed manually)</li>
                    <li><code>arena</code>: Request-scoped allocator that's automatically freed after the request (recommended for most use cases)</li>
                </ul>
                <p>Use <code>ctx.arena</code> for temporary allocations that only need to persist during request processing. This is the recommended allocator for most page and component code.</p>
            </section>
            <section id="builtin-attributes" class="section">
                <h2>Builtin Attributes</h2>
                <p>ZX provides special builtin attributes that control component behavior and memory management. These attributes are prefixed with <code>@</code> to distinguish them from regular HTML attributes.</p>
                <h3>@allocator</h3>
                <p>The <code>@allocator</code> attribute is required to be passed to the topmost component. All child components will inherit the allocator from the parent component. It is available to all child components and expressions within that component tree.</p>
                <p><strong>Why is @allocator needed?</strong></p>
                <p>ZX components can allocate memory for various purposes:</p>
                <ul>
                    <li>Storing text content (which is HTML-escaped and allocated)</li>
                    <li>Copying child components arrays</li>
                    <li>Copying attribute arrays</li>
                    <li>Formatting expressions that allocate formatted strings</li>
                </ul>
                <p><strong>Usage:</strong></p>
                <ExampleBlock id="allocator" zx_code={zx_example_allocator} zig_code={zig_example_allocator} html_code={html_example_allocator} />
                <p><strong>Best Practices:</strong></p>
                <ul>
                    <li>Always use <code>ctx.arena</code> in page components (it's automatically freed after the request)</li>
                    <li>Pass the allocator parameter to custom components and use it in the <code>@allocator</code> attribute</li>
                    <li>Set <code>@allocator</code> on the root element of each component that needs memory allocation</li>
                    <li>Child components inherit the allocator from their parent's component, so you don't need to pass it explicitly to every nested component</li>
                </ul>
                <h3>@escaping</h3>
                <p>The <code>@escaping</code> attribute controls how text content is escaped within an element. By default, all text is HTML-escaped to prevent XSS attacks.</p>
                <p><strong>Values:</strong></p>
                <ul>
                    <li><code>.default</code> - Standard HTML escaping (default behavior)</li>
                    <li><code>.raw</code> - No escaping; outputs raw HTML. Use with caution for trusted content only.</li>
                </ul>
                <ExampleBlock id="escaping" zx_code={zx_example_escaping} zig_code={zig_example_escaping} html_code={html_example_escaping} />
                <p><strong>Warning:</strong> Only use <code>@escaping={"{.raw}"}</code> for content you trust completely. User-provided content should always use the default escaping.</p>
                <h3>@rendering</h3>
                <p>The <code>@rendering</code> attribute enables client-side rendering for interactive components.</p>
                <p><strong>Values:</strong></p>
                <ul>
                    <li><code>.csr</code> - Client-side render with React (for imported React/TSX components)</li>
                    <li><code>.csz</code> - Client-side render with Zig (compile component to WebAssembly)</li>
                </ul>
                <ExampleBlock id="csr" zx_code={zx_example_csr} zig_code={zig_example_csr} html_code={html_example_csr} />
            </section>
            <section id="importing" class="section">
                <h2>Importing</h2>
                <p>ZX supports importing components and modules from various sources. You can import ZX components from other files, React/TSX components for client-side interactivity, and standard Zig modules.</p>
                <ExampleBlock id="importing" zx_code={zx_example_importing} zig_code={zig_example_importing} html_code={html_example_importing} />
                <p>Use <code>@jsImport</code> for React/TSX components and the standard <code>@import</code> for ZX and Zig files.</p>
            </section>
            <section id="dynamic-routes" class="section">
                <h2>Dynamic Routes</h2>
                <p>ZX supports dynamic route segments using bracket notation in folder names.</p>
                <h3>Creating Dynamic Routes</h3>
                <p>Create a folder with brackets around the parameter name:</p>
                <ul>
                    <li><code>site/pages/user/[id]/page.zx</code> → <code>/user/:id</code></li>
                    <li><code>site/pages/blog/[slug]/page.zx</code> → <code>/blog/:slug</code></li>
                    <li><code>site/pages/[category]/[item]/page.zx</code> → <code>/:category/:item</code></li>
                </ul>
                <h3>Accessing Route and Query Parameters</h3>
                <p>Use <code>ctx.request.param("name")</code> to access dynamic route parameters and <code>ctx.request.query("name")</code> for query strings:</p>
                <ExampleBlock id="dynamic-route" zx_code={zx_example_dynamic} zig_code={zig_example_dynamic} html_code={html_example_dynamic} />
                <p>Both methods return <code>?[]const u8</code>, so use <code>orelse</code> to provide a default value.</p>
            </section>
            <section id="fragments" class="section">
                <h2>Fragments</h2>
                <p>Fragments allow you to return multiple elements from a component without adding an extra wrapper element to the DOM. Use the empty tag syntax <code>{"<>...</>"}</code> to create a fragment:</p>
                <ExampleBlock id="fragment" zx_code={zx_example_fragment} zig_code={zig_example_fragment} html_code={html_example_fragment} />
                <p>The fragment's children are rendered directly without any containing element.</p>
            </section>
            <section id="children-props" class="section">
                <h2>Children Props</h2>
                <p>Components can accept child elements through a <code>children</code> prop, enabling wrapper and container patterns. Any elements between the opening and closing tags are passed as the <code>children</code> prop:</p>
                <ExampleBlock id="children" zx_code={zx_example_children} zig_code={zig_example_children} html_code={html_example_children} />
                <p>Multiple children are automatically wrapped in a fragment.</p>
            </section>            
            // <ExamplesSection />
      
        </div>
    );
}

const zx = @import("zx");
const std = @import("std");
const root = @import("root");
const util = @import("util.zig");

const Introduction = @import("../components/introduction.zig").Introduction;
const GettingStarted = @import("../components/getting_started.zig").GettingStarted;
const ExamplesSection = @import("../components/examples_section.zig").ExamplesSection;
const ExampleBlock = @import("../components/example_block.zig").ExampleBlock;
