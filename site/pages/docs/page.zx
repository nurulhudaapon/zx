pub fn Page(ctx: zx.PageContext) zx.Component {
    var page_timer = std.time.Timer.start() catch unreachable;
    const allocator = ctx.arena;
    
    std.log.info("\x1b[1;36m[DOCS PAGE] Starting page generation...\x1b[0m", .{});
    
    // If example
    var aw_if: std.io.Writer.Allocating = .init(allocator);
    const zx_example_if = @embedFile("../../../pages/examples/if.zx");
    const zig_example_if = @embedFile("../examples/if.zig");
    const html_page_if = @import("../examples/if.zig").Page(allocator);
    html_page_if.render(&aw_if.writer) catch unreachable;
    const html_example_if = allocator.dupe(u8, aw_if.written()) catch unreachable;

    // Switch example
    var aw_switch: std.io.Writer.Allocating = .init(allocator);
    const zx_example_switch = @embedFile("../../../pages/examples/switch.zx");
    const zig_example_switch = @embedFile("../examples/switch.zig");
    const html_page_switch = @import("../examples/switch.zig").Page(allocator);
    html_page_switch.render(&aw_switch.writer) catch unreachable;
    const html_example_switch = allocator.dupe(u8, aw_switch.written()) catch unreachable;

    // For example
    var aw_for: std.io.Writer.Allocating = .init(allocator);
    const zx_example_for = @embedFile("../../../pages/examples/for.zx");
    const zig_example_for = @embedFile("../examples/for.zig");
    const html_page_for = @import("../examples/for.zig").Page(allocator);
    html_page_for.render(&aw_for.writer) catch unreachable;
    const html_example_for = allocator.dupe(u8, aw_for.written()) catch unreachable;

    // Component expression example
    var aw_component: std.io.Writer.Allocating = .init(allocator);
    const zx_example_component = @embedFile("../../../pages/examples/component.zx");
    const zig_example_component = @embedFile("../examples/component.zig");
    const html_page_component = @import("../examples/component.zig").Page(allocator);
    html_page_component.render(&aw_component.writer) catch unreachable;
    const html_example_component = allocator.dupe(u8, aw_component.written()) catch unreachable;

    // Text expression example
    var aw_text: std.io.Writer.Allocating = .init(allocator);
    const zx_example_text = @embedFile("../../../pages/examples/text.zx");
    const zig_example_text = @embedFile("../examples/text.zig");
    const html_page_text = @import("../examples/text.zig").Page(allocator);
    html_page_text.render(&aw_text.writer) catch unreachable;
    const html_example_text = allocator.dupe(u8, aw_text.written()) catch unreachable;

    // Format expression example
    var aw_format: std.io.Writer.Allocating = .init(allocator);
    const zx_example_format = @embedFile("../../../pages/examples/format.zx");
    const zig_example_format = @embedFile("../examples/format.zig");
    const html_page_format = @import("../examples/format.zig").Page(allocator);
    html_page_format.render(&aw_format.writer) catch unreachable;
    const html_example_format = allocator.dupe(u8, aw_format.written()) catch unreachable;

    // Components example
    var aw_components: std.io.Writer.Allocating = .init(allocator);
    const zx_example_components = @embedFile("../../../pages/examples/components.zx");
    const zig_example_components = @embedFile("../examples/components.zig");
    const html_page_components = @import("../examples/components.zig").Page(ctx);
    html_page_components.render(&aw_components.writer) catch unreachable;
    const html_example_components = allocator.dupe(u8, aw_components.written()) catch unreachable;

    // Routing example
    var aw_routing: std.io.Writer.Allocating = .init(allocator);
    const zx_example_routing = @embedFile("../../../pages/examples/routing.zx");
    const zig_example_routing = @embedFile("../examples/routing.zig");
    const html_page_routing = @import("../examples/routing.zig").Page(ctx);
    html_page_routing.render(&aw_routing.writer) catch unreachable;
    const html_example_routing = allocator.dupe(u8, aw_routing.written()) catch unreachable;

    // Layout example
    var aw_layout: std.io.Writer.Allocating = .init(allocator);
    const zx_example_layout = @embedFile("../../../pages/layout.zx");
    const zig_example_layout = @embedFile("../examples/layout.zig");
    const layoutctx = zx.LayoutContext.init(ctx.request, ctx.response, ctx.allocator);
    const html_page_layout = @import("../examples/layout.zig").Layout(layoutctx, html_page_routing);
    html_page_layout.render(&aw_layout.writer) catch unreachable;
    const html_example_layout = allocator.dupe(u8, aw_layout.written()) catch unreachable;

    // Allocator example
    var aw_allocator: std.io.Writer.Allocating = .init(allocator);
    const zx_example_allocator = @embedFile("../../../pages/examples/allocator.zx");
    const zig_example_allocator = @embedFile("../examples/allocator.zig");
    const html_page_allocator = @import("../examples/allocator.zig").Page(ctx);
    html_page_allocator.render(&aw_allocator.writer) catch unreachable;
    const html_example_allocator = allocator.dupe(u8, aw_allocator.written()) catch unreachable;

    const cmp_expr = "{(expression)}";
    const txt_expr = "{expression}";
    const fmt_expr = "{[expression:format]}";

    
    const setup_elapsed_ns = page_timer.read();
    const setup_elapsed_ms = @as(f64, @floatFromInt(setup_elapsed_ns)) / @as(f64, @floatFromInt(std.time.ns_per_ms));
    std.log.info("\x1b[1;36m[DOCS PAGE] Setup phase completed: {d:.3}ms\x1b[0m", .{setup_elapsed_ms});

    return (
        <div @allocator={allocator}>
            <Introduction />
            <GettingStarted />

                    <section id="expressions" class="section">
                        <h2>Expressions</h2>

                        <p>ZX provides different expression syntaxes for embedding dynamic content. Each syntax serves a
                            specific purpose: rendering components, displaying text safely, or formatting values with custom
                            format specifiers.</p>


                        <h3>Text Expressions</h3>

                        <p>Use <code>{txt_expr}</code> to embed text content. All text is automatically HTML-escaped to prevent
                            XSS attacks. This is the safe way to display user input or dynamic text content.</p>

                        <ExampleBlock id="text" zx_code={zx_example_text} zig_code={zig_example_text}
                            html_code={html_example_text} />

                        <h3>Format Expressions</h3>

                        <p>Use <code>{fmt_expr}</code> to format values with custom format specifiers. The format string follows
                            Zig's standard format specifier syntax (e.g., <code>d</code> for decimal, <code>x</code> for
                            hexadecimal). Unlike text expressions, format expressions are not HTML-escaped, making them suitable
                            for numeric formatting and other non-HTML content.</p>
                        <ExampleBlock id="format" zx_code={zx_example_format} zig_code={zig_example_format}
                            html_code={html_example_format} />

                        <h3>Component Expressions</h3>

                        <p>Use <code>{cmp_expr}</code> to embed a component directly. The expression must evaluate to a
                            <code>zx.Component</code> type. This is useful when you want to conditionally render or reuse
                            components dynamically.
                        </p>

                        <ExampleBlock id="component" zx_code={zx_example_component} zig_code={zig_example_component}
                            html_code={html_example_component} />
                    </section>


                    <section id="control-flow" class="section">
                        <h2>Control Flow</h2>
                        <p>ZX supports conditional rendering and iteration using familiar Zig control flow constructs. These
                            expressions allow you to conditionally render components or iterate over collections to build
                            dynamic UIs.</p>

                        <h3>If Statements</h3>
                        <p>Use <code>if</code> expressions to conditionally render components based on boolean conditions. The
                            <code>else</code> branch is optional and can render alternative content when the condition is false.
                        </p>
                        <ExampleBlock id="if" zx_code={zx_example_if} zig_code={zig_example_if} html_code={html_example_if} />

                        <h3>Switch Statements</h3>
                        <p>Use <code>switch</code> expressions to match against enum values or other types. Each case can return
                            either a string literal or a component. Switch expressions are particularly useful for rendering
                            different UI based on state or user roles.</p>
                        <ExampleBlock id="switch" zx_code={zx_example_switch} zig_code={zig_example_switch}
                            html_code={html_example_switch} />

                        <h3>For Loops</h3>
                        <p>Use <code>for</code> loops to iterate over arrays, slices, or strings and render a component for each
                            item. The loop variable can be used within the component body to display item-specific content. This
                            is ideal for rendering lists, tables, or any repeating UI patterns.</p>
                        <ExampleBlock id="for" zx_code={zx_example_for} zig_code={zig_example_for}
                            html_code={html_example_for} />
                    </section>

                    <section id="components" class="section">
                        <h2>Components</h2>
                        <p>Components are reusable functions that return <code>zx.Component</code>. They allow you to
                            encapsulate UI logic and create modular, maintainable code. Components can accept props (properties)
                            to customize their
                            behavior and appearance.</p>

                        <h3>Component Function Signatures</h3>
                        <p>Component functions must follow one of two signatures:</p>
                        <ul>
                            <li><strong>Single parameter (allocator only):</strong> <code>fn ComponentName(allocator:
                                    zx.Allocator)
                                    zx.Component</code></li>
                            <li><strong>Two parameters (allocator and props):</strong> <code>fn ComponentName(allocator:
                                    zx.Allocator,
                                    props: PropsType) zx.Component</code></li>
                        </ul>

                        <h3>Defining Components</h3>
                        <p>To create a component, define a function that returns a <code>zx.Component</code>. The function must
                            have an allocator as its first parameter. If your component needs configuration, add a props struct
                            as the
                            second parameter:</p>
                        <ExampleBlock id="components" zx_code={zx_example_components} zig_code={zig_example_components}
                            html_code={html_example_components} />

                        <h3>Props Coercion</h3>
                        <p>ZX automatically coerces the attributes you pass to a component into the expected props struct.
                            Missing required fields will result in a compile-time error, while fields with default values are
                            optional. This
                            provides type safety while keeping component usage flexible.</p>
                    </section>

                    <section id="routing" class="section">
                        <h2>Routing</h2>
                        <p>ZX provides a file-based routing system that maps URL paths to page components. Routes can be nested,
                            and layouts can be applied hierarchically to wrap pages with common UI elements.</p>

                        <h3>Pages</h3>
                        <p>Pages are the main content components for each route. A page function must:</p>
                        <ul>
                            <li>Accept a <code>zx.PageContext</code> as its only parameter</li>
                            <li>Return a <code>zx.Component</code></li>
                            <li>Be exported as <code>pub fn Page</code></li>
                        </ul>
                        <ExampleBlock id="routing" zx_code={zx_example_routing} zig_code={zig_example_routing}
                            html_code={html_example_routing} />

                        <h3>Layouts</h3>
                        <p>Layouts wrap pages with common UI elements like headers, footers, or navigation. A layout function
                            must:</p>
                        <ul>
                            <li>Accept a <code>zx.LayoutContext</code> as the first parameter</li>
                            <li>Accept a <code>zx.Component</code> (the page content) as the second parameter</li>
                            <li>Return a <code>zx.Component</code></li>
                            <li>Be exported as <code>pub fn Layout</code></li>
                        </ul>
                        <ExampleBlock id="layout" zx_code={zx_example_layout} zig_code={zig_example_layout}
                            html_code={html_example_layout} />

                        <h3>PageContext and LayoutContext</h3>
                        <p>Both <code>PageContext</code> and <code>LayoutContext</code> provide access to:</p>
                        <ul>
                            <li><code>request</code>: The HTTP request object with headers, query params, body, etc.</li>
                            <li><code>response</code>: The HTTP response object for setting headers and writing the response
                            </li>
                            <li><code>allocator</code>: Global allocator for persistent allocations (freed manually)</li>
                            <li><code>arena</code>: Request-scoped allocator that's automatically freed after the request
                                (recommended for most use cases)</li>
                        </ul>
                        <p>Use <code>ctx.arena</code> for temporary allocations that only need to persist during request
                            processing. This is the recommended allocator for most page and component code.</p>
                    </section>

                    <section id="builtin-attributes" class="section">
                        <h2>Builtin Attributes</h2>
                        <p>ZX provides special builtin attributes that control component behavior and memory management. These
                            attributes are prefixed with <code>@</code> to distinguish them from regular HTML attributes.</p>

                        <h3>@allocator</h3>
                        <p>The <code>@allocator</code> attribute is required to be passed to the topmost component. All child
                            components will inherit the allocator from the parent component. It is available to all child
                            components and expressions within that component tree.</p>

                        <p><strong>Why is @allocator needed?</strong></p>
                        <p>ZX components can allocate memory for various purposes:</p>
                        <ul>
                            <li>Storing text content (which is HTML-escaped and allocated)</li>
                            <li>Copying child components arrays</li>
                            <li>Copying attribute arrays</li>
                            <li>Formatting expressions that allocate formatted strings</li>
                        </ul>

                        <p><strong>Usage:</strong></p>
                        <ExampleBlock id="allocator" zx_code={zx_example_allocator} zig_code={zig_example_allocator}
                            html_code={html_example_allocator} />

                        <p><strong>Best Practices:</strong></p>
                        <ul>
                            <li>Always use <code>ctx.arena</code> in page components (it's automatically freed after the
                                request)</li>
                            <li>Pass the allocator parameter to custom components and use it in the <code>@allocator</code>
                                attribute</li>
                            <li>Set <code>@allocator</code> on the root element of each component that needs memory allocation
                            </li>
                            <li>Child components inherit the allocator from their parent's component, so you don't need to pass
                                it explicitly to every nested component</li>
                        </ul>
                    </section>

            <ExamplesSection />
        </div>

    );
}

const zx = @import("zx");
const std = @import("std");
const root = @import("root");
const util = @import("util.zig");

const Introduction = @import("../components/introduction.zig").Introduction;
const GettingStarted = @import("../components/getting_started.zig").GettingStarted;
const ExamplesSection = @import("../components/examples_section.zig").ExamplesSection;
const ExampleBlock = @import("../components/example_block.zig").ExampleBlock;
