pub fn Page(ctx: zx.PageContext) zx.Component {
    // var page_timer = std.time.Timer.start() catch unreachable;
    const allocator = ctx.arena;

    // std.log.info("\x1b[1;36m[DOCS PAGE] Starting page generation...\x1b[0m", .{});

    // If example
    var aw_if: std.io.Writer.Allocating = .init(allocator);
    const zx_example_if = @embedFile("../../../pages/examples/if.zx");
    const zig_example_if = @embedFile("../examples/if.zig");
    const html_page_if = @import("../examples/if.zig").Conditional(allocator);
    html_page_if.render(&aw_if.writer) catch unreachable;
    const html_example_if = allocator.dupe(u8, aw_if.written()) catch unreachable;

    // Switch example
    var aw_switch: std.io.Writer.Allocating = .init(allocator);
    const zx_example_switch = @embedFile("../../../pages/examples/switch.zx");
    const zig_example_switch = @embedFile("../examples/switch.zig");
    const html_page_switch = @import("../examples/switch.zig").RoleSwitch(allocator);
    html_page_switch.render(&aw_switch.writer) catch unreachable;
    const html_example_switch = allocator.dupe(u8, aw_switch.written()) catch unreachable;

    // For example
    var aw_for: std.io.Writer.Allocating = .init(allocator);
    const zx_example_for = @embedFile("../../../pages/examples/for.zx");
    const zig_example_for = @embedFile("../examples/for.zig");
    const html_page_for = @import("../examples/for.zig").UserList(allocator);
    html_page_for.render(&aw_for.writer) catch unreachable;
    const html_example_for = allocator.dupe(u8, aw_for.written()) catch unreachable;

    // While example
    var aw_while: std.io.Writer.Allocating = .init(allocator);
    const zx_example_while = @embedFile("../../../pages/examples/while.zx");
    const zig_example_while = @embedFile("../examples/while.zig");
    const html_page_while = @import("../examples/while.zig").Counter(allocator);
    html_page_while.render(&aw_while.writer) catch unreachable;
    const html_example_while = allocator.dupe(u8, aw_while.written()) catch unreachable;

    // Expression example
    var aw_expr: std.io.Writer.Allocating = .init(allocator);
    const zx_example_expr = @embedFile("../../../pages/examples/text.zx");
    const zig_example_expr = @embedFile("../examples/text.zig");
    const html_page_expr = @import("../examples/text.zig").Expressions(allocator);
    html_page_expr.render(&aw_expr.writer) catch unreachable;
    const html_example_expr = allocator.dupe(u8, aw_expr.written()) catch unreachable;

    // Components example
    var aw_components: std.io.Writer.Allocating = .init(allocator);
    const zx_example_components = @embedFile("../../../pages/examples/components.zx");
    const zig_example_components = @embedFile("../examples/components.zig");
    const html_page_components = @import("../examples/components.zig").ButtonDemo(ctx);
    html_page_components.render(&aw_components.writer) catch unreachable;
    const html_example_components = allocator.dupe(u8, aw_components.written()) catch unreachable;

    // Routing example
    var aw_routing: std.io.Writer.Allocating = .init(allocator);
    const zx_example_routing = @embedFile("../../../pages/examples/routing.zx");
    const zig_example_routing = @embedFile("../examples/routing.zig");
    const html_page_routing = @import("../examples/routing.zig").Page(ctx);
    html_page_routing.render(&aw_routing.writer) catch unreachable;
    const html_example_routing = allocator.dupe(u8, aw_routing.written()) catch unreachable;

    // Layout example - use simple example like learn page
    var aw_layout: std.io.Writer.Allocating = .init(allocator);
    const zx_example_layout = @embedFile("../../../pages/learn/examples/layout_example.zx");
    const zig_example_layout = @embedFile("../../../pages/learn/examples/.zx/layout_example.zig");
    const layoutctx = zx.LayoutContext.init(ctx.request, ctx.response, ctx.allocator);
    const html_page_layout = @import("../learn/examples/.zx/layout_example.zig").Layout(layoutctx, zx.Component{ .text = "Hello, World!" });
    html_page_layout.render(&aw_layout.writer) catch unreachable;
    const html_example_layout = allocator.dupe(u8, aw_layout.written()) catch unreachable;

    // Allocator example
    var aw_allocator: std.io.Writer.Allocating = .init(allocator);
    const zx_example_allocator = @embedFile("../../../pages/examples/allocator.zx");
    const zig_example_allocator = @embedFile("../examples/allocator.zig");
    const html_page_allocator = @import("../examples/allocator.zig").AllocatorDemo(ctx);
    html_page_allocator.render(&aw_allocator.writer) catch unreachable;
    const html_example_allocator = allocator.dupe(u8, aw_allocator.written()) catch unreachable;

    const expr_syntax = "{expression}";

    // Expression type examples
    const expr_string_example =
        \\const name = "Alice";
        \\...
        \\(<p>{name}</p>) // <p>Alice</p>
    ;
    const expr_int_example =
        \\const count: u32 = 42;
        \\...
        \\(<p>{count}</p>) // <p>42</p>
    ;
    const expr_float_example =
        \\const price: f32 = 19.99;
        \\...
        \\(<p>${price}</p>) // <p>$19.99</p>
    ;
    const expr_bool_example =
        \\const active = true;
        \\...
        \\(<p>{active}</p>) // <p>true</p>
    ;
    const expr_enum_example =
        \\const Status = enum { pending, approved, rejected };
        \\const status = Status.approved;
        \\...
        \\(<p>{status}</p>) // <p>approved</p>
    ;
    const expr_optional_example =
        \\const maybe_name: ?[]const u8 = "Bob";
        \\...
        \\(<p>{maybe_name}</p>) // <p>Bob</p>
        \\
        \\
        \\const no_name: ?[]const u8 = null;
        \\...
        \\(<p>{no_name}</p>) // <p></p> (empty)
    ;
    const expr_component_example =
        \\const header = Header(allocator);
        \\...
        \\(<div>{header}</div>) // Renders the Header component
    ;
    const expr_component_array_example =
        \\const items: []zx.Component = &.{ Item("A"), Item("B") };
        \\...
        \\(<ul>{items}</ul>) // Renders both Item components
    ;

    // Escaping example
    var aw_escaping: std.io.Writer.Allocating = .init(allocator);
    const zx_example_escaping = @embedFile("../../../pages/examples/escaping.zx");
    const zig_example_escaping = @embedFile("../examples/escaping.zig");
    const html_page_escaping = @import("../examples/escaping.zig").RawHtml(allocator);
    html_page_escaping.render(&aw_escaping.writer) catch unreachable;
    const html_example_escaping = allocator.dupe(u8, aw_escaping.written()) catch unreachable;

    // CSR example
    var aw_csr: std.io.Writer.Allocating = .init(allocator);
    const zx_example_csr = @embedFile("../../../pages/examples/react.zx");
    const zig_example_csr = @embedFile("../examples/react.zig");
    const html_page_csr = @import("../examples/react.zig").ReactDemo(allocator);
    html_page_csr.render(&aw_csr.writer) catch unreachable;
    const html_example_csr = allocator.dupe(u8, aw_csr.written()) catch unreachable;

    // Importing example
    var aw_importing: std.io.Writer.Allocating = .init(allocator);
    const zx_example_importing = @embedFile("../../../pages/examples/importing.zx");
    const zig_example_importing = @embedFile("../examples/importing.zig");
    const html_page_importing = @import("../examples/importing.zig").ImportDemo(allocator);
    html_page_importing.render(&aw_importing.writer) catch unreachable;
    const html_example_importing = allocator.dupe(u8, aw_importing.written()) catch unreachable;

    // Dynamic route example
    var aw_dynamic: std.io.Writer.Allocating = .init(allocator);
    const zx_example_dynamic = @embedFile("../../../pages/examples/dynamic_route.zx");
    const zig_example_dynamic = @embedFile("../examples/dynamic_route.zig");
    const html_page_dynamic = @import("../examples/dynamic_route.zig").UserProfile(ctx);
    html_page_dynamic.render(&aw_dynamic.writer) catch unreachable;
    const html_example_dynamic = allocator.dupe(u8, aw_dynamic.written()) catch unreachable;

    // Fragment example
    var aw_fragment: std.io.Writer.Allocating = .init(allocator);
    const zx_example_fragment = @embedFile("../../../pages/examples/fragment.zx");
    const zig_example_fragment = @embedFile("../examples/fragment.zig");
    const html_page_fragment = @import("../examples/fragment.zig").FragmentDemo(allocator);
    html_page_fragment.render(&aw_fragment.writer) catch unreachable;
    const html_example_fragment = allocator.dupe(u8, aw_fragment.written()) catch unreachable;

    // Children example
    var aw_children: std.io.Writer.Allocating = .init(allocator);
    const zx_example_children = @embedFile("../../../pages/examples/children.zx");
    const zig_example_children = @embedFile("../examples/children.zig");
    const html_page_children = @import("../examples/children.zig").CardDemo(allocator);
    html_page_children.render(&aw_children.writer) catch unreachable;
    const html_example_children = allocator.dupe(u8, aw_children.written()) catch unreachable;

    // const setup_elapsed_ns = page_timer.read();
    // const setup_elapsed_ms = @as(f64, @floatFromInt(setup_elapsed_ns)) / @as(f64, @floatFromInt(std.time.ns_per_ms));
    // std.log.info("\x1b[1;36m[DOCS PAGE] Setup phase completed: {d:.3}ms\x1b[0m", .{setup_elapsed_ms});


    // Allocate files on heap to avoid stack lifetime issues
    const layout_files = blk: {
        const files = allocator.alloc(File, 2) catch unreachable;
        files[0] = .{ .filename = "layout.zx", .code = zx_example_layout };
        files[1] = .{ .filename = "page.zx", .code = zx_example_routing };
        break :blk files;
    };
    return (
        <div @allocator={allocator}>
            <Introduction />
            <section id="expressions" class="section">
                <h2>Expressions</h2>
                <p>Use curly braces <code>{expr_syntax}</code> to embed any Zig expression. Values are automatically formatted based on their type and HTML-escaped for safety.</p>
                <ExampleBlock id="expressions-example" zx_code={zx_example_expr} zig_code={zig_example_expr} html_code={html_example_expr} filename="expressions.zx" />
                
                <h3 id="expr-strings">Strings</h3>
                <p>String values (<code>[]const u8</code>) are displayed as text and automatically HTML-escaped to prevent XSS attacks. This is the safe default for displaying user input or any dynamic text content.</p>
                <CodeBlock code={expr_string_example} />
                
                <h3 id="expr-integers">Integers</h3>
                <p>Integer types (<code>i32</code>, <code>u64</code>, <code>comptime_int</code>, etc.) are formatted as decimal numbers. The special case <code>u8</code> is printed as a character if it's a printable ASCII character.</p>
                <CodeBlock code={expr_int_example} />
                
                <h3 id="expr-floats">Floats</h3>
                <p>Floating-point types (<code>f32</code>, <code>f64</code>, <code>comptime_float</code>) are formatted as decimal numbers.</p>
                <CodeBlock code={expr_float_example} />
                
                <h3 id="expr-booleans">Booleans</h3>
                <p>Boolean values are displayed as the literal strings "true" or "false".</p>
                <CodeBlock code={expr_bool_example} />
                
                <h3 id="expr-enums">Enums</h3>
                <p>Enum values are displayed as their tag name. This is useful for displaying status values, categories, or any enumerated type.</p>
                <CodeBlock code={expr_enum_example} />
                
                <h3 id="expr-optionals">Optionals</h3>
                <p>Optional values (<code>?T</code>) are automatically unwrapped and rendered if present. If the value is <code>null</code>, nothing is rendered. This makes it easy to conditionally display content.</p>
                <CodeBlock code={expr_optional_example} />
                
                <h3 id="expr-null">Null</h3>
                <p>The <code>null</code> value renders nothing, producing no output in the final HTML.</p>
                
                <h3 id="expr-components">Components</h3>
                <p>A <code>zx.Component</code> value is rendered directly. This allows you to embed components returned from functions or stored in variables.</p>
                <CodeBlock code={expr_component_example} />
                
                <h3 id="expr-component-arrays">Component Arrays</h3>
                <p>Arrays or slices of components (<code>[]zx.Component</code>) are rendered as a fragment containing all the components in sequence.</p>
                <CodeBlock code={expr_component_array_example} />
            </section>
            <section id="control-flow" class="section">
                <h2>Control Flow</h2>
                <p>ZX supports conditional rendering and iteration using familiar Zig control flow constructs. These expressions allow you to conditionally render components or iterate over collections to build dynamic UIs.</p>
                <h3 id="if-statements">If Statements</h3>
                <p>Use <code>if</code> expressions to conditionally render components based on boolean conditions. The<code>else</code> branch is optional and can render alternative content when the condition is false.</p>
                <ExampleBlock id="if" zx_code={zx_example_if} zig_code={zig_example_if} html_code={html_example_if} filename="conditional.zx" />
                <h3 id="switch-statements">Switch Statements</h3>
                <p>Use <code>switch</code> expressions to match against enum values or other types. Each case can return either a string literal or a component. Switch expressions are particularly useful for rendering different UI based on state or user roles.</p>
                <ExampleBlock id="switch" zx_code={zx_example_switch} zig_code={zig_example_switch} html_code={html_example_switch} filename="role_switch.zx" />
                <h3 id="for-loops">For Loops</h3>
                <p>Use <code>for</code> loops to iterate over arrays, slices, or strings and render a component for each item. The loop variable can be used within the component body to display item-specific content. This is ideal for rendering lists, tables, or any repeating UI patterns.</p>
                <ExampleBlock id="for" zx_code={zx_example_for} zig_code={zig_example_for} html_code={html_example_for} filename="user_list.zx" />
                <h3 id="while-loops">While Loops</h3>
                <p>Use <code>while</code> loops for conditional iteration with a continuation expression. The syntax follows Zig's while loop pattern: <code>{"while (condition) : (continue_expr) (body)"}</code>. This is useful for generating numbered sequences or iterating until a condition is met.</p>
                <ExampleBlock id="while" zx_code={zx_example_while} zig_code={zig_example_while} html_code={html_example_while} filename="counter.zx" />
            </section>
            <section id="components" class="section">
                <h2>Components</h2>
                <p>Components are reusable functions that return <code>zx.Component</code>. They allow you to encapsulate UI logic and create modular, maintainable code. Components can accept props (properties) to customize their behavior and appearance.</p>
                <h3>Component Function Signatures</h3>
                <p>Component functions must follow one of two signatures:</p>
                <ul>
                    <li><strong>Single parameter (allocator only):</strong><code>fn ComponentName(allocator: zx.Allocator) zx.Component</code></li>
                    <li><strong>Two parameters (allocator and props):</strong><code>fn ComponentName(allocator: zx.Allocator, props: PropsType) zx.Component</code></li>
                </ul>
                <h3>Defining Components</h3>
                <p>To create a component, define a function that returns a <code>zx.Component</code>. The function must have an allocator as its first parameter. If your component needs configuration, add a props struct as the second parameter:</p>
                <ExampleBlock id="components" zx_code={zx_example_components} zig_code={zig_example_components} html_code={html_example_components} filename="button_demo.zx" />
                <h3>Props Coercion</h3>
                <p>ZX automatically coerces the attributes you pass to a component into the expected props struct. Missing required fields will result in a compile-time error, while fields with default values are optional. This provides type safety while keeping component usage flexible.</p>
            </section>
            <section id="routing" class="section">
                <h2>Routing</h2>
                <p>ZX provides a file-based routing system that maps URL paths to page components. Routes can be nested, and layouts can be applied hierarchically to wrap pages with common UI elements.</p>
                <h3 id="pages">Pages</h3>
                <p>Pages are the main content components for each route. A page function must:</p>
                <ul>
                    <li>Accept a <code>zx.PageContext</code> as its only parameter</li>
                    <li>Return a <code>zx.Component</code></li>
                    <li>Be exported as <code>pub fn Page</code></li>
                </ul>
                <ExampleBlock id="routing" zx_code={zx_example_routing} zig_code={zig_example_routing} html_code={html_example_routing} filename="home_page.zx" />
                <h3 id="layouts">Layouts</h3>
                <p>Layouts wrap pages with common UI elements like headers, footers, or navigation. A layout function must:</p>
                <ul>
                    <li>Accept a <code>zx.LayoutContext</code> as the first parameter</li>
                    <li>Accept a <code>zx.Component</code> (the page content) as the second parameter</li>
                    <li>Return a <code>zx.Component</code></li>
                    <li>Be exported as <code>pub fn Layout</code></li>
                </ul>
                <ExampleBlock id="layout" files={layout_files} zig_code={zig_example_layout} html_code={html_example_layout} />
                <h3>PageContext and LayoutContext</h3>
                <p>Both <code>PageContext</code> and <code>LayoutContext</code> provide access to:</p>
                <ul>
                    <li><code>request</code>: The HTTP request object with headers, query params, body, etc.</li>
                    <li><code>response</code>: The HTTP response object for setting headers and writing the response</li>
                    <li><code>allocator</code>: Global allocator for persistent allocations (freed manually)</li>
                    <li><code>arena</code>: Request-scoped allocator that's automatically freed after the request (recommended for most use cases)</li>
                </ul>
                <p>Use <code>ctx.arena</code> for temporary allocations that only need to persist during request processing. This is the recommended allocator for most page and component code.</p>
            </section>
            <section id="builtin-attributes" class="section">
                <h2>Builtin Attributes</h2>
                <p>ZX provides special builtin attributes that control component behavior and memory management. These attributes are prefixed with <code>@</code> to distinguish them from regular HTML attributes.</p>
                <h3 id="allocator">@allocator</h3>
                <p>The <code>@allocator</code> attribute is required to be passed to the topmost component. All child components will inherit the allocator from the parent component. It is available to all child components and expressions within that component tree.</p>
                <p><strong>Why is @allocator needed?</strong></p>
                <p>ZX components can allocate memory for various purposes:</p>
                <ul>
                    <li>Storing text content (which is HTML-escaped and allocated)</li>
                    <li>Copying child components arrays</li>
                    <li>Copying attribute arrays</li>
                    <li>Formatting expressions that allocate formatted strings</li>
                </ul>
                <p><strong>Usage:</strong></p>
                <ExampleBlock id="allocator" zx_code={zx_example_allocator} zig_code={zig_example_allocator} html_code={html_example_allocator} filename="allocator_demo.zx" />
                <p><strong>Best Practices:</strong></p>
                <ul>
                    <li>Always use <code>ctx.arena</code> in page components (it's automatically freed after the request)</li>
                    <li>Pass the allocator parameter to custom components and use it in the <code>@allocator</code> attribute</li>
                    <li>Set <code>@allocator</code> on the root element of each component that needs memory allocation</li>
                    <li>Child components inherit the allocator from their parent's component, so you don't need to pass it explicitly to every nested component</li>
                </ul>
                <h3 id="escaping">@escaping</h3>
                <p>The <code>@escaping</code> attribute controls how text content is escaped within an element. By default, all text is HTML-escaped to prevent XSS attacks.</p>
                <p><strong>Values:</strong></p>
                <ul>
                    <li><code>.default</code> - Standard HTML escaping (default behavior)</li>
                    <li><code>.raw</code> - No escaping; outputs raw HTML. Use with caution for trusted content only.</li>
                </ul>
                <ExampleBlock id="escaping" zx_code={zx_example_escaping} zig_code={zig_example_escaping} html_code={html_example_escaping} filename="raw_html.zx" />
                <p><strong>Warning:</strong> Only use <code>@escaping={"{.raw}"}</code> for content you trust completely. User-provided content should always use the default escaping.</p>
                <h3 id="rendering">@rendering</h3>
                <p>The <code>@rendering</code> attribute enables client-side rendering for interactive components.</p>
                <p><strong>Values:</strong></p>
                <ul>
                    <li><code>.react</code> - Client-side render with React (for imported React/TSX components)</li>
                    <li><code>.client</code> - Client-side render with Zig (compile component to WebAssembly)</li>
                </ul>
                <ExampleBlock id="react" zx_code={zx_example_csr} zig_code={zig_example_csr} html_code={html_example_csr} filename="react_demo.zx" />
            </section>
            <section id="importing" class="section">
                <h2>Importing</h2>
                <p>ZX supports importing components and modules from various sources. You can import ZX components from other files, React/TSX components for client-side interactivity, and standard Zig modules.</p>
                <ExampleBlock id="importing" zx_code={zx_example_importing} zig_code={zig_example_importing} html_code={html_example_importing} filename="import_demo.zx" />
                <p>Use <code>@jsImport</code> for React/TSX components and the standard <code>@import</code> for ZX and Zig files.</p>
            </section>
            <section id="dynamic-routes" class="section">
                <h2>Dynamic Routes</h2>
                <p>ZX supports dynamic route segments using bracket notation in folder names.</p>
                <h3>Creating Dynamic Routes</h3>
                <p>Create a folder with brackets around the parameter name:</p>
                <ul>
                    <li><code>site/pages/user/[id]/page.zx</code> → <code>/user/:id</code></li>
                    <li><code>site/pages/blog/[slug]/page.zx</code> → <code>/blog/:slug</code></li>
                    <li><code>site/pages/[category]/[item]/page.zx</code> → <code>/:category/:item</code></li>
                </ul>
                <h3>Accessing Route and Query Parameters</h3>
                <p>Use <code>ctx.request.param("name")</code> to access dynamic route parameters and <code>ctx.request.query("name")</code> for query strings:</p>
                <ExampleBlock id="dynamic-route" zx_code={zx_example_dynamic} zig_code={zig_example_dynamic} html_code={html_example_dynamic} filename="user_profile.zx" />
                <p>Both methods return <code>?[]const u8</code>, so use <code>orelse</code> to provide a default value.</p>
            </section>
            <section id="fragments" class="section">
                <h2>Fragments</h2>
                <p>Fragments allow you to return multiple elements from a component without adding an extra wrapper element to the DOM. Use the empty tag syntax <code>{"<>...</>"}</code> to create a fragment:</p>
                <ExampleBlock id="fragment" zx_code={zx_example_fragment} zig_code={zig_example_fragment} html_code={html_example_fragment} filename="fragment_demo.zx" />
                <p>The fragment's children are rendered directly without any containing element.</p>
            </section>
            <section id="children-props" class="section">
                <h2>Children Props</h2>
                <p>Components can accept child elements through a <code>children</code> prop, enabling wrapper and container patterns. Any elements between the opening and closing tags are passed as the <code>children</code> prop:</p>
                <ExampleBlock id="children" zx_code={zx_example_children} zig_code={zig_example_children} html_code={html_example_children} filename="card_demo.zx" />
            </section>
            <PluginsSection />
            // <ExamplesSection />
      
        </div>
    );
}

const zx = @import("zx");
const std = @import("std");
const root = @import("root");
const util = @import("util.zig");

const Introduction = @import("../components/introduction.zig").Introduction;
const ExamplesSection = @import("../components/examples_section.zig").ExamplesSection;
const example_block = @import("../components/example_block.zig");
const ExampleBlock = example_block.ExampleBlock;
const File = example_block.File;
const CodeBlock = @import("../components/code_block.zig").CodeBlock;

fn PluginsSection(allocator: zx.Allocator) zx.Component {
    const tailwind_full_example =
        \\const zx = @import("zx");
        \\const std = @import("std");
        \\
        \\pub fn build(b: *std.Build) !void {
        \\    const target = b.standardTargetOptions(.{});
        \\    const optimize = b.standardOptimizeOption(.{});
        \\    
        \\    const zx_dep = b.dependency("zx", .{ .target = target, .optimize = optimize });
        \\    const exe = b.addExecutable(.{
        \\        .name = "my-app",
        \\        .root_module = b.createModule(.{
        \\            .root_source_file = b.path("site/main.zig"),
        \\            .target = target,
        \\            .optimize = optimize,
        \\        }),
        \\    });
        \\
        \\    try zx.init(b, exe, .{
        \\        .plugins = &.{
        \\            zx.plugins.tailwind(b, .{
        \\                .bin = b.path("node_modules/.bin/tailwindcss"),
        \\                .input = b.path("site/assets/styles.css"),
        \\                .output = b.path("{outdir}/assets/styles.css"),
        \\                .minify = optimize != .Debug,
        \\            }),
        \\        },
        \\    });
        \\}
    ;
    const esbuild_full_example =
        \\const zx = @import("zx");
        \\const std = @import("std");
        \\
        \\pub fn build(b: *std.Build) !void {
        \\    // ... setup code ...
        \\
        \\    try zx.init(b, exe, .{
        \\        .plugins = &.{
        \\            zx.plugins.esbuild(b, .{
        \\                .bin = b.path("node_modules/.bin/esbuild"),
        \\                .input = b.path("site/main.ts"),
        \\                .output = b.path("{outdir}/assets/main.js"),
        \\                .bundle = true,
        \\                .format = .esm,
        \\                .platform = .browser,
        \\                .target = "es2020",
        \\                .external = &.{ "react", "react-dom" },
        \\                .define = &.{
        \\                    .{ .key = "API_URL", .value = "\"https://api.example.com\"" },
        \\                },
        \\            }),
        \\        },
        \\    });
        \\}
    ;
    const combined_example =
        \\try zx.init(b, exe, .{
        \\    .plugins = &.{
        \\        zx.plugins.esbuild(b, .{
        \\            .input = b.path("site/main.ts"),
        \\            .output = b.path("{outdir}/assets/main.js"),
        \\        }),
        \\        zx.plugins.tailwind(b, .{
        \\            .input = b.path("site/assets/styles.css"),
        \\            .output = b.path("{outdir}/assets/styles.css"),
        \\        }),
        \\    },
        \\});
    ;
    const custom_plugin_example =
        \\const zx = @import("zx");
        \\const std = @import("std");
        \\
        \\pub fn build(b: *std.Build) !void {
        \\    // ... setup code ...
        \\
        \\    try zx.init(b, exe, .{
        \\        .plugins = &.{
        \\            // Custom plugin using PluginOptions directly
        \\            createImageOptimizer(b),
        \\        },
        \\    });
        \\}
        \\
        \\fn createImageOptimizer(b: *std.Build) zx.ZxInitOptions.PluginOptions {
        \\    const cmd = std.Build.Step.Run.create(b, "optimize-images");
        \\    
        \\    // Add your custom command
        \\    cmd.addArgs(&.{ "npx", "imagemin", "site/public/**/*", "--out-dir={outdir}/public" });
        \\    
        \\    // Allocate steps array
        \\    const steps = b.allocator.alloc(zx.ZxInitOptions.PluginOptions.PluginStep, 1) catch @panic("OOM");
        \\    steps[0] = .{
        \\        .command = .{
        \\            .type = .after_transpile,  // Run after ZX transpilation
        \\            .run = cmd,
        \\        },
        \\    };
        \\    
        \\    return .{
        \\        .name = "image-optimizer",
        \\        .steps = steps,
        \\    };
        \\}
    ;
    const plugin_options_struct =
        \\/// Configuration for build plugins
        \\pub const PluginOptions = struct {
        \\    /// Human-readable name for this plugin
        \\    name: []const u8,
        \\    
        \\    /// List of steps this plugin should execute
        \\    steps: []const PluginStep,
        \\    
        \\    pub const PluginStep = union(enum) {
        \\        command: PluginStepCommand,
        \\    };
        \\    
        \\    pub const PluginStepCommand = struct {
        \\        /// When to execute: before_transpile or after_transpile
        \\        type: enum { before_transpile, after_transpile },
        \\        
        \\        /// The command to run (use {outdir} for output directory)
        \\        run: *std.Build.Step.Run,
        \\    };
        \\};
    ;

    return (
        <section id="plugins" class="section" @allocator={allocator}>
            <h2>Plugins</h2>
            <p>ZX provides a plugin system to extend the build process with additional tools. Plugins run as build steps and integrate seamlessly with <code>zig build</code>.</p>
            
            <h3 id="plugin-overview">Overview</h3>
            <p>Plugins are configured in your <code>build.zig</code> file and passed to <code>zx.init()</code>. Each plugin adds build steps that run before or after ZX transpilation, allowing you to process CSS, bundle JavaScript, or run other tools.</p>
            <p>ZX provides <strong>builtin plugins</strong> for common tasks, and you can also <strong>create custom plugins</strong> for your specific needs.</p>

            <h3 id="builtin-plugins">Builtin Plugins</h3>
            <p>ZX ships with the following builtin plugins available via <code>zx.plugins</code>:</p>
            <ul>
                <li><strong><code>zx.plugins.tailwind</code></strong> — Compile Tailwind CSS styles</li>
                <li><strong><code>zx.plugins.esbuild</code></strong> — Bundle TypeScript/JavaScript for client-side code</li>
            </ul>

            <h3 id="tailwind-plugin">Tailwind CSS Plugin</h3>
            <p>The <code>tailwind</code> builtin plugin compiles your CSS using the Tailwind CSS CLI. It automatically runs after ZX transpiles your pages.</p>
            
            <h4>Options</h4>
            <table class="options-table">
                <thead>
                    <tr>
                        <th>Option</th>
                        <th>Type</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>bin</code></td>
                        <td><code>?LazyPath</code></td>
                        <td><code>node_modules/.bin/tailwindcss</code></td>
                        <td>Path to the Tailwind CLI binary</td>
                    </tr>
                    <tr>
                        <td><code>input</code></td>
                        <td><code>?LazyPath</code></td>
                        <td><code>site/assets/styles.css</code></td>
                        <td>Input CSS file with Tailwind directives</td>
                    </tr>
                    <tr>
                        <td><code>output</code></td>
                        <td><code>?LazyPath</code></td>
                        <td><code>{"{outdir}"}/assets/styles.css</code></td>
                        <td>Output path for compiled CSS</td>
                    </tr>
                    <tr>
                        <td><code>minify</code></td>
                        <td><code>bool</code></td>
                        <td><code>false</code></td>
                        <td>Optimize and minify the output</td>
                    </tr>
                    <tr>
                        <td><code>optimize</code></td>
                        <td><code>bool</code></td>
                        <td><code>false</code></td>
                        <td>Optimize output without minifying</td>
                    </tr>
                    <tr>
                        <td><code>cwd</code></td>
                        <td><code>?LazyPath</code></td>
                        <td><code>null</code></td>
                        <td>Working directory for Tailwind</td>
                    </tr>
                    <tr>
                        <td><code>map</code></td>
                        <td><code>bool</code></td>
                        <td><code>false</code></td>
                        <td>Generate a source map</td>
                    </tr>
                </tbody>
            </table>
            
            <h4>Example</h4>
            <CodeBlock code={tailwind_full_example} filename="build.zig" />

            <h3 id="esbuild-plugin">esbuild Plugin</h3>
            <p>The <code>esbuild</code> builtin plugin bundles TypeScript or JavaScript files for client-side code. It supports modern JavaScript features and can bundle dependencies.</p>
            
            <h4>Options</h4>
            <table class="options-table">
                <thead>
                    <tr>
                        <th>Option</th>
                        <th>Type</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>bin</code></td>
                        <td><code>?LazyPath</code></td>
                        <td><code>node_modules/.bin/esbuild</code></td>
                        <td>Path to the esbuild binary</td>
                    </tr>
                    <tr>
                        <td><code>input</code></td>
                        <td><code>?LazyPath</code></td>
                        <td><code>site/main.ts</code></td>
                        <td>Entry point file</td>
                    </tr>
                    <tr>
                        <td><code>output</code></td>
                        <td><code>?LazyPath</code></td>
                        <td><code>{"{outdir}"}/assets/main.js</code></td>
                        <td>Output file path</td>
                    </tr>
                    <tr>
                        <td><code>bundle</code></td>
                        <td><code>bool</code></td>
                        <td><code>true</code></td>
                        <td>Bundle all dependencies</td>
                    </tr>
                    <tr>
                        <td><code>minify</code></td>
                        <td><code>?bool</code></td>
                        <td><code>true</code> in release</td>
                        <td>Minify the output</td>
                    </tr>
                    <tr>
                        <td><code>sourcemap</code></td>
                        <td><code>?enum</code></td>
                        <td><code>inline</code> in debug</td>
                        <td>Source map mode: <code>none</code>, <code>inline</code>, <code>external</code>, <code>linked</code>, <code>both</code></td>
                    </tr>
                    <tr>
                        <td><code>log_level</code></td>
                        <td><code>?enum</code></td>
                        <td><code>silent</code></td>
                        <td>Log level: <code>verbose</code>, <code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>, <code>silent</code></td>
                    </tr>
                    <tr>
                        <td><code>format</code></td>
                        <td><code>?enum</code></td>
                        <td>inferred</td>
                        <td>Output format: <code>iife</code>, <code>cjs</code>, <code>esm</code></td>
                    </tr>
                    <tr>
                        <td><code>platform</code></td>
                        <td><code>?enum</code></td>
                        <td><code>browser</code></td>
                        <td>Target platform: <code>browser</code>, <code>node</code>, <code>neutral</code></td>
                    </tr>
                    <tr>
                        <td><code>target</code></td>
                        <td><code>?[]const u8</code></td>
                        <td><code>esnext</code></td>
                        <td>Environment target (e.g., <code>es2017</code>, <code>chrome58</code>)</td>
                    </tr>
                    <tr>
                        <td><code>splitting</code></td>
                        <td><code>bool</code></td>
                        <td><code>false</code></td>
                        <td>Enable code splitting (ESM only)</td>
                    </tr>
                    <tr>
                        <td><code>external</code></td>
                        <td><code>[]const []const u8</code></td>
                        <td><code>&.{"{}"}</code></td>
                        <td>Modules to exclude from bundle</td>
                    </tr>
                    <tr>
                        <td><code>define</code></td>
                        <td><code>[]const struct</code></td>
                        <td><code>&.{"{}"}</code></td>
                        <td>Custom substitutions (key-value pairs)</td>
                    </tr>
                </tbody>
            </table>
            
            <p><strong>Automatic defines:</strong> The esbuild plugin automatically sets <code>__DEV__</code> and <code>process.env.NODE_ENV</code> based on the build mode.</p>
            
            <h4>Example</h4>
            <CodeBlock code={esbuild_full_example} filename="build.zig" />

            <h3 id="combining-plugins">Combining Plugins</h3>
            <p>You can use multiple plugins together. They run in order after ZX transpilation:</p>
            <CodeBlock code={combined_example} />

            <h3 id="custom-plugins">Creating Custom Plugins</h3>
            <p>You can create your own plugins by returning a <code>zx.ZxInitOptions.PluginOptions</code> struct. This allows you to integrate any command-line tool into the ZX build process.</p>
            
            <h4>Plugin Structure</h4>
            <p>A plugin consists of a name and a list of steps. Each step specifies when to run (before or after transpilation) and what command to execute:</p>
            <CodeBlock code={plugin_options_struct} />

            <h4>Example: Custom Image Optimizer Plugin</h4>
            <p>Here's how to create a custom plugin that optimizes images during the build:</p>
            <CodeBlock code={custom_plugin_example} filename="build.zig" />

            <h4>Plugin Lifecycle</h4>
            <ul>
                <li><strong><code>before_transpile</code></strong> — Runs before ZX transpiles <code>.zx</code> files to Zig. Useful for preprocessing source files.</li>
                <li><strong><code>after_transpile</code></strong> — Runs after ZX transpilation. Useful for post-processing like CSS compilation, JS bundling, or asset optimization.</li>
            </ul>

            <h4>Using <code>{"{outdir}"}</code></h4>
            <p>In output paths, use <code>{"{outdir}"}</code> as a placeholder for the ZX output directory.</p>

            <div class="callout tip">
                <strong>Tip:</strong> Look at the builtin plugins (<code>tailwind.zig</code> and <code>esbuild.zig</code> in the ZX source) for examples of how to structure complex plugins with many options.
            </div>
        </section>
    );
}
