pub fn Page(ctx: zx.PageContext) zx.Component {
    const allocator = ctx.arena;
    return (
        <div @allocator={allocator} class="todo-container">
            <TodoApp @rendering={.client} />

            <style>
                {[@embedFile("style.css"):s]}
            </style>
            <script type="module" src="/assets/main.js" />
        </div>
    );
}

const Todo = struct { id: u32, text: []const u8, completed: bool };
var todos = std.ArrayList(Todo).empty;

pub fn TodoApp(allocator: zx.Allocator) zx.Component {
    initTodos(allocator);

    return (
        <div @allocator={allocator} class="todo-app">
            <div class="todo-header">
                <h1 class="todo-title">ZX + WASM</h1>
                <p class="todo-subtitle">A demo todo app built with ZX Client Side Rendering</p>
            </div>

            <form class="todo-input-section" onsubmit={addTodo}>
                <input type="text" class="todo-input" id="todo-input" placeholder="Add a new todo..." />
                <button class="todo-add-btn" type="submit">Add</button>
            </form>

            <div class="todo-stats">
                <div class="todo-stat">
                    <span class="todo-stat-value">{todos.items.len}</span>
                    <span class="todo-stat-label">Total</span>
                </div>
                <div class="todo-stat">
                    <span class="todo-stat-value">{countCompleted()}</span>
                    <span class="todo-stat-label">Completed</span>
                </div>
                <div class="todo-stat">
                    <span class="todo-stat-value">{(todos.items.len - countCompleted())}</span>
                    <span class="todo-stat-label">Remaining</span>
                </div>
            </div>

            <ul class="todo-list">
                {for (todos.items) |todo| (
                    <TodoItem id={todo.id} text={todo.text} completed={todo.completed} />
                )}
            </ul>

            <button class="todo-clear-btn" onclick={clearTodos}>Clear All</button>
        </div>
    );
}

const TodoItemProps = struct {
    id: u32,
    text: []const u8,
    completed: bool,
};
fn TodoItem(allocator: zx.Allocator, props: TodoItemProps) zx.Component {
    const class = if (props.completed) "todo-item todo-item-completed" else "todo-item";
    const @"data-completed" = if (props.completed) "true" else "false";
    const key = props.id;

    return (
        <li @{allocator} {class} {key} {@"data-completed"}>
            <input type="button" class="todo-checkbox" value={props.id} onclick={toggleTodo}>
                {if (props.completed) "âœ“" else ""}
            </input>
            <span>
                {props.text}
            </span>
        </li>
    );
}

const initial_todos = [_]Todo{
    .{ .id = 1, .text = "Build a fast web app with ZX", .completed = true },
    .{ .id = 3, .text = "Implement server-side rendering", .completed = true },
    .{ .id = 4, .text = "Implement client-side rendering", .completed = false },
};
var initialized: bool = false;
fn initTodos(allocator: zx.Allocator) void {
    if (initialized) return;
    initialized = true;
    todos.appendSlice(allocator, &initial_todos) catch @panic("OOM");
}

fn addTodo(ctx: zx.EventContext) void {
    if (builtin.os.tag != .freestanding) return;
    ctx.preventDefault();
    const allocator = std.heap.wasm_allocator;
    const document = zx.Client.bom.Document.init(allocator);
    const input = document.getElementById("todo-input") catch return;

    const text = input.ref.getAlloc(js.String, allocator, "value") catch return;
    if (text.len == 0) return;

    todos.append(allocator, .{ .id = todos.items.len + 1, .text = text, .completed = false }) catch @panic("OOM");
    input.ref.set("value", js.string("")) catch return;
}

fn handleInputChange(ctx: zx.EventContext) void {
    if (builtin.os.tag != .freestanding) return;
    const allocator = std.heap.wasm_allocator;

    const event = client.Event.idInit(allocator, ctx.id) catch return;
    const value = event.target.value;

    todos.append(allocator, .{ .id = todos.items.len, .text = value, .completed = false }) catch @panic("OOM");
}
fn toggleTodo(ctx: zx.EventContext) void {
    if (builtin.os.tag != .freestanding) return;
    const allocator = std.heap.wasm_allocator;

    const event = client.Event.idInit(allocator, ctx.id) catch return;
    var id: ?u32 = null;
    const target = event.target;
    if (target) |t| {
        const value = t.value;
        if (value) |v| {
            id = std.fmt.parseInt(u32, v, 10) catch return;
        }
    }

    for (todos.items) |*todo| {
        if (todo.id == id) {
            todo.completed = !todo.completed;
            break;
        }
    }
}

fn clearTodos(_: zx.EventContext) void {
    if (builtin.os.tag != .freestanding) return;
    todos.clearRetainingCapacity();
}

fn countCompleted() u32 {
    var count: u32 = 0;
    for (todos.items) |todo| {
        if (todo.completed) count += 1;
    }
    return count;
}

const zx = @import("zx");
const std = @import("std");
const builtin = @import("builtin");
const client = zx.Client.bom;
const js = zx.Client.js;
