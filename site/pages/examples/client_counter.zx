var count = zx.Signal(i32).init(0);
var doubled = zx.Computed(i32, i32).init(&count, doubleValue);

pub fn CounterComponent(allocator: zx.Allocator) zx.Component {
    return (
        <div @allocator={allocator}>
            <button onclick={handleReset}>Reset</button>
            <h5>Count: {&count}</h5>
            <h5>Doubled: {&doubled}</h5>
            <button onclick={handleDecrement}>Decrement</button>
            <button onclick={handleIncrement}>Increment</button>
            <p>{&message}</p>
        </div>
    );
}
fn doubleValue(val: i32) i32 {
    return val * 2;
}

fn handleIncrement(_: zx.EventContext) void {
    countEffect.run();
    count.set(count.get() + 1);
}

fn handleDecrement(_: zx.EventContext) void {
    countEffect.run();
    count.set(count.get() - 1);
}

fn handleReset(_: zx.EventContext) void {
    countEffect.run();
    count.set(0);
}

// TODO: The API of effect will change
var countEffect = zx.Effect(i32).init(&count, onCountChange);
var message = zx.Signal([]const u8).init("Count Didn't Change");

fn onCountChange(newCount: i32) void {
    _ = newCount;
    message.set("Count Changed");
}

const zx = @import("zx");
