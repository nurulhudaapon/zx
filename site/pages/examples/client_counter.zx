var count: zx.Signal(i32) = .init(0);
var doubled: zx.Computed(i32, i32) = .init(&count, doubleValue);

pub fn CounterComponent(allocator: zx.Allocator) zx.Component {
    zx.effect(&count, &onCountChange);
    zx.effect(&doubled, &onDoubledChange);

    return (
        <div @allocator={allocator}>
            <button onclick={handleReset}>Reset</button>
            <h5>Count: {&count}</h5>
            <h5>Doubled: {&doubled}</h5>
            <NestedCounterComponent count={&count} />
            <button onclick={handleDecrement}>Decrement</button>
            <button onclick={handleIncrement}>Increment</button>
            // <button onclick={handleSubmit}>Submit</button>
            <p>{&message}</p>
        </div>
    );
}

pub fn NestedCounterComponent(ctx: *zx.ComponentCtx(struct { count: *zx.Signal(i32) })) zx.Component {
    return (<h5 @allocator={ctx.allocator}>Nested Count: {ctx.props.count}</h5>);
}

fn doubleValue(val: i32) i32 {
    return val * 2;
}

fn handleIncrement(_: zx.EventContext) void {
    count.set(count.get() + 1);
}

fn handleDecrement(_: zx.EventContext) void {
    count.set(count.get() - 1);
}

fn handleReset(_: zx.EventContext) void {
    count.set(0);
}

// fn handleSubmit(ctx: zx.ActionContext) zx.ActionResult(void) {
//     std.log.info("handleSubmit", .{});
// }

var message = zx.Signal([]const u8).init("Count Didn't Change");

/// Effect callback that returns an optional cleanup function.
/// The cleanup runs before the next effect execution.
fn onCountChange(newCount: i32) zx.CleanupFn {
    const new_msg = std.fmt.allocPrint(zx.client_allocator, "Count Changed: {d}", .{newCount}) catch "Count Changed";
    message.set(new_msg);

    std.log.err("onCountChange newCount: {d}", .{newCount});

    
    return onCleanup;
}

fn onCleanup() void {
    std.log.info("Cleanup", .{});
}

fn onDoubledChange(newDoubled: i32) void {
    std.log.err("onDoubledChange newDoubled: {d}", .{newDoubled});
}

const std = @import("std");
const zx = @import("zx");
